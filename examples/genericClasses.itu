
/*
// Lvl 1: Contain generic arguments
type Simple = <T> {
    value: T;
};

const simple = new Simple<int>();

const val = simple.value;

type SimpleConsumer = {
    simple: Simple<int>;
};

const consumer = new SimpleConsumer;
consumer.simple = simple;

// Lvl 2: Recursive type definitions
type List = <T> {
    value: T;
    next: List<T>; // knows T to be specified
};

let b = new List<int>();
let c = new List<int>().next;
let a = new List<int>().next.next.next.next;

*/

type list = <T> {
    value: T;
    next: list<T>;

    Add (item: T): list<T> {
        const newList = new list<T>();
        newList.next = this;
        newList.value = item;
        return newList;
    }
};

//type intList = list<int>;

//const listOfInts: list<int> = new intList().Add(6);

type User = {
    items: list<int>;
};

const user = new User();
user.items.Add(5);

/*

Types "Simple" => GenericWrappper {
    Bindings = {{"T", GenericIdentifier("T")}},
    Handle = { GenericIdentifier("T") },
    Child = ClassType
    {
        Members = {
            {"value", GenericIdentifier("T")}
        }
    }
};

Values "simple" => GenericWrappper {
    Bindings = {"T", IntType},
    Handle = { GenericIdentifier("T") },
    Child = ClassType
    {
        Members = {
            {"value", GenericIdentifier("T")}
        }
    }
}

Resolve -> ClassType
{
    Members = {
        {"value", GenericWrapper {

        }}
    }
}

type Other = <T> {
    func: <P>(P) => T;
    funcSwapped: <P>(T) => Other<P>;
}

Types "Other" => GenericWrapper {
    Bindings = {{"T", GenericIdentifier("T")}},
    Handle = { "T" },
    Child = ClassType {
        Members = {
            {"func", GenericWrapper {
                Bindings = {{"P", GenericIdentifier("P")}},
                Child = FunctionType {
                    ReturnType = GenericIdentifier("T"),
                    ParameterTypes = [GenericIdentifier("P")]
                }
            }},
            {"funcSwapped", GenericWrapper {
                Bindings = {{"P", GenericIdentifier("P")}},
                Handle = { "P" },
                Child = FunctionType {
                    ReturnType = GenericWrapper {
                        Bindings = {{"T", GenericIdentifier("P")}},
                        Handle = { "T" },
                        Child = "Other".Child,
                    },
                    ParameterTypes = [GenericIdentifier("T")]
                }
            }},
        }
    }
}

Types "List" => GenericWrapper {
    Bindings = {{"T", GenericIdentifier("T")}},
    Handle = { GenericIdentifier("T") },
    Child = ClassType {
        Members = {
            {"value", GenericIdentifier("T")},
            {"next", GenericWrapper {
                Bindings = {{"T", GenericIdentifier("T")}},
                Child = "List".Child
            }},
            {"Add", GenericWrapper {
                Bindings = {{"P", GenericIdentifier("P")}},
                Child = FunctionType {
                    ReturnType = GenericWrapper {
                        Bindings = {{"T", GenericIdentifier("T")}},
                        Child = "List".Child
                    },
                    ParameterTypes = [GenericIdentifier("T")]
                    ParameterNames = ["item"]
                }
            }}
        }
    }
}

const intList = new List<int>();
intList.Add(5);

Values "intList" => GenericWrapper {
    Bindings = {{"T", IntType}},
    Child = "List".Child
}

// Specification -> Binding of an identifier to a concrete type ("T" -> int)
// Resolution -> Get a concrete version of the type with all identifiers replaced with their specified counterpart
*/
